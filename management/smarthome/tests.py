from datetime import datetime
from decimal import Decimal
from collections import OrderedDict
from django.test import TestCase
from mock import patch
from rest_framework.test import APIClient
from users.models import User

from .constants import EnergySource as sources
from .energy_calculators.energy_exchange_calc import EnergyExchangeCalculator
from .energy_calculators import (EnergyStorageCalculator,
                                 GridSurplusEnergyCalculator,
                                 PhotovoltaicsEnergyCalculator,
                                 PublicGridEnergyCalculator)
from .measurements_manager import EnergyMeasurementsManager
from .models import (Building, EnergyDailyMeasurement, EnergyGenerator,
                     EnergyReceiver, EnergyStorage, EnergySurplusLossRaport,
                     EnergySurplusRaport, ExchangeEnergyStorageRaport)
from services.smart_home import SmartHomeStorageChargingAndUsageRaport, SmartHomeChargeStateRaport

class EnergyTestCase(TestCase):
    client = APIClient()

    def setUpBuildingSinglePhotovoltaics(self):
        user = User.objects.create(email="defaultuser@email.com", password="defaultpassword")
        building = Building.objects.create(user=user, name="house")
        receiver = EnergyReceiver.objects.create(building=building, name="bulb", state=False, device_power=60, supply_voltage=8)
        generator = EnergyGenerator.objects.create(name='photovoltaics1', building=building, generation_power = 635.0)
        return {
            "building": building,
            "devices": [receiver],
            "generators": [generator],
        }


    def test_calculate_single_photovoltaics_is_enough(self):
        """Energy generated by single photovoltaics is enough to power every device"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        generator = db["generators"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=5),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=10)
        ]
        energy_sources = {
                sources.PHOTOVOLTAICS: PhotovoltaicsEnergyCalculator,
                sources.GRID_SURPLUS: GridSurplusEnergyCalculator,
                sources.PUBLIC_GRID: PublicGridEnergyCalculator,
            }

        with patch.object(EnergyMeasurementsManager, '_get_energy_measurements', return_value=measurements):
            _, source_raport, _ = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

            first_raport = source_raport[0]
            photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],5)
            self.assertEqual(photovoltaics_data["price"],0)

            surplus =  EnergySurplusRaport.objects.filter(building=building).latest('date_time')
            surplus_loss = EnergySurplusLossRaport.objects.filter(building=building).latest('date_time')
            
            self.assertEqual(surplus.usage_type, EnergySurplusRaport.TRANSFER)
            self.assertEqual(surplus.value, 0.8*5) #80 percent of unused energy
            self.assertEqual(surplus_loss.value, 0.2*5)


    def test_calculate_no_photovoltaics_public_grid_only(self):
        """There is no photovoltaics so its necessary to use only the public grid energy"""
        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=5),
        ]
        energy_sources = {
                sources.PHOTOVOLTAICS: PhotovoltaicsEnergyCalculator,
                sources.GRID_SURPLUS: GridSurplusEnergyCalculator,
                sources.PUBLIC_GRID: PublicGridEnergyCalculator,
            }
        with patch.object(EnergyMeasurementsManager, '_get_energy_measurements', return_value=measurements):
            _, source_raport, _ = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

            first_raport = source_raport[0]
            photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],0)
            self.assertEqual(photovoltaics_data["price"],0)

            public_grid_data = first_raport.energy_sources[sources.PUBLIC_GRID]
            self.assertEqual(public_grid_data["value"],5)
            self.assertEqual(public_grid_data["price"],Decimal("3.4"))

    def test_calculate_photovoltaics_and_grid_surplus_are_enough(self):
        """Energy generated by photovoltaics + grid surplus are enough to power every device"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        generator = db["generators"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        EnergySurplusRaport.objects.create(building = building, value=6.25, date_time = start_date, usage_type = EnergySurplusRaport.TRANSFER)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=10),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=5)
        ]

        energy_sources = {
                sources.PHOTOVOLTAICS: PhotovoltaicsEnergyCalculator,
                sources.GRID_SURPLUS: GridSurplusEnergyCalculator,
                sources.PUBLIC_GRID: PublicGridEnergyCalculator,
            }
        with patch.object(EnergyMeasurementsManager, '_get_energy_measurements', return_value=measurements):
            _, source_raport, _ = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

            first_raport = source_raport[0]
            photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],5)
            self.assertEqual(photovoltaics_data["price"],0)

            grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
            self.assertEqual(grid_surplus_data["value"],5)
            self.assertEqual(grid_surplus_data["price"],0)

            surplus =  EnergySurplusRaport.objects.filter(building=building).latest('date_time')
            
            self.assertEqual(surplus.usage_type, EnergySurplusRaport.DEVICES_POWERING)
            self.assertEqual(surplus.value, 0)


    def test_calculate_no_photovoltaics_grid_surplus_only(self):
        """There is no photovoltaics, but grid surplus are enough to power every device"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        EnergySurplusRaport.objects.create(building = building, value=10, date_time = start_date, usage_type = EnergySurplusRaport.TRANSFER)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=5)
        ]

        energy_sources = {
                sources.PHOTOVOLTAICS: PhotovoltaicsEnergyCalculator,
                sources.GRID_SURPLUS: GridSurplusEnergyCalculator,
                sources.PUBLIC_GRID: PublicGridEnergyCalculator,
            }
        with patch.object(EnergyMeasurementsManager, '_get_energy_measurements', return_value=measurements):
            _, source_raport, _ = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

            first_raport = source_raport[0]

            photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],0)
            self.assertEqual(photovoltaics_data["price"],0)

            grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
            self.assertEqual(grid_surplus_data["value"],5)
            self.assertEqual(grid_surplus_data["price"],0)
            
            public_grid_data = first_raport.energy_sources[sources.PUBLIC_GRID]
            self.assertEqual(public_grid_data["value"],0)
            self.assertEqual(public_grid_data["price"],Decimal("0.0"))

            surplus =  EnergySurplusRaport.objects.filter(building=building).latest('date_time')
            
            self.assertEqual(surplus.usage_type, EnergySurplusRaport.DEVICES_POWERING)
            self.assertEqual(surplus.value, 3)

    def test_calculate_photovoltaics_grid_surplus_and_public_grid(self):
        """Energy generated by photovoltaics + grid surplus are not enough to power every device, so its necessary to use also the public grid energy"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        generator = db["generators"][0]
        receiver = db["devices"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        EnergySurplusRaport.objects.create(building = building, value=10, date_time = start_date, usage_type = EnergySurplusRaport.TRANSFER)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=25),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=10)
        ]

        energy_sources = {
                sources.PHOTOVOLTAICS: PhotovoltaicsEnergyCalculator,
                sources.GRID_SURPLUS: GridSurplusEnergyCalculator,
                sources.PUBLIC_GRID: PublicGridEnergyCalculator,
            }
        with patch.object(EnergyMeasurementsManager, '_get_energy_measurements', return_value=measurements):
            _, source_raport, _ = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

            first_raport = source_raport[0]

            photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],10)
            self.assertEqual(photovoltaics_data["price"],0)

            grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
            self.assertEqual(grid_surplus_data["value"],8)
            self.assertEqual(grid_surplus_data["price"],0)
            
            public_grid_data = first_raport.energy_sources[sources.PUBLIC_GRID]
            self.assertEqual(public_grid_data["value"],7)
            self.assertEqual(public_grid_data["price"],Decimal("4.76"))

            surplus =  EnergySurplusRaport.objects.filter(building=building).latest('date_time')
            
            self.assertEqual(surplus.usage_type, EnergySurplusRaport.DEVICES_POWERING)
            self.assertEqual(surplus.value,0.0)
    
    def test_calculate_photovoltaics_and_public_grid(self):
        """Energy generated by photovoltaics is not enough to power every device, there is no grid surplus energy, so its necessary to use the public grid energy"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        generator = db["generators"][0]
        receiver = db["devices"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=25),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=10)
        ]

        energy_sources = {
                sources.PHOTOVOLTAICS: PhotovoltaicsEnergyCalculator,
                sources.GRID_SURPLUS: GridSurplusEnergyCalculator,
                sources.PUBLIC_GRID: PublicGridEnergyCalculator,
            }
        with patch.object(EnergyMeasurementsManager, '_get_energy_measurements', return_value=measurements):
            _, source_raport, _ = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

            first_raport = source_raport[0]

            photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],10)
            self.assertEqual(photovoltaics_data["price"],0)

            grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
            self.assertEqual(grid_surplus_data["value"],0)
            self.assertEqual(grid_surplus_data["price"],0)
            
            public_grid_data = first_raport.energy_sources[sources.PUBLIC_GRID]
            self.assertEqual(public_grid_data["value"],15)
            self.assertEqual(public_grid_data["price"],Decimal("10.20"))

    def test_calculate_grid_surplus_and_public_grid(self):
        """There is no energy generated by photovoltaics, grid surplus energy is not enough to power every device, so its necessary to use the public grid energy"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        generator = db["generators"][0]
        receiver = db["devices"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        EnergySurplusRaport.objects.create(building = building, value=10, date_time = start_date, usage_type = EnergySurplusRaport.TRANSFER)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=25),
        ]

        energy_sources = {
                sources.PHOTOVOLTAICS: PhotovoltaicsEnergyCalculator,
                sources.GRID_SURPLUS: GridSurplusEnergyCalculator,
                sources.PUBLIC_GRID: PublicGridEnergyCalculator,
            }
        with patch.object(EnergyMeasurementsManager, '_get_energy_measurements', return_value=measurements):
            _, source_raport, _ = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

            first_raport = source_raport[0]

            photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],0)
            self.assertEqual(photovoltaics_data["price"],0)

            grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
            self.assertEqual(grid_surplus_data["value"],8)
            self.assertEqual(grid_surplus_data["price"],0)
            
            public_grid_data = first_raport.energy_sources[sources.PUBLIC_GRID]
            self.assertEqual(public_grid_data["value"],17)
            self.assertEqual(public_grid_data["price"],Decimal("11.56"))

            surplus =  EnergySurplusRaport.objects.filter(building=building).latest('date_time')

            self.assertEqual(surplus.usage_type, EnergySurplusRaport.DEVICES_POWERING)
            self.assertEqual(surplus.value, 0.0)

    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_energy_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_raports')
    def test_calculate_photovoltaics_and_energy_storage_are_enough(self, mock_raports, mock_storage, mock_measurements):
        """Energy generated by photovoltaics + energy storage are enough to power every device"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        generator = db["generators"][0]
        storage = EnergyStorage.objects.create(name='storage', building=building, capacity=100, battery_voltage=10)

        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=10),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=5)
        ]

        storage_measurements = [
            SmartHomeChargeStateRaport({"device":storage, "date":start_date, "charge_value":storage.capacity})
        ]

        storage_raports = [
            # SmartHomeStorageChargingAndUsageRaport(device=storage, date_time_from=start_date, date_time_to=end_date)
        ]
        mock_measurements.return_value = measurements
        mock_storage.return_value = storage_measurements
        mock_raports.return_value = storage_raports

        energy_sources = OrderedDict([
                (sources.PHOTOVOLTAICS, PhotovoltaicsEnergyCalculator),
                (sources.GRID_SURPLUS, GridSurplusEnergyCalculator),
                (sources.ENERGY_STORAGE, EnergyStorageCalculator),
                (sources.PUBLIC_GRID, PublicGridEnergyCalculator),
                ])

        _, source_raport, surpluses = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)


        first_raport = source_raport[0]
        photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
        self.assertEqual(photovoltaics_data["value"],5)
        self.assertEqual(photovoltaics_data["price"],0)

        grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
        self.assertEqual(grid_surplus_data["value"],0)
        self.assertEqual(grid_surplus_data["price"],0)

        energy_storage_data = first_raport.energy_sources[sources.ENERGY_STORAGE]
        self.assertEqual(energy_storage_data["value"],5)
        self.assertEqual(energy_storage_data["price"],0)

    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_energy_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_raports')
    def test_calculate_photovoltaics_is_enough_to_charge_energy_storage(self, mock_raports, mock_storage, mock_measurements):
        """Energy generated by photovoltaics is enought to power every device and to charge energy storage"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        generator = db["generators"][0]
        storage = EnergyStorage.objects.create(name='storage', building=building, capacity=6, battery_voltage=24)

        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=10),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=15)
        ]

        storage_measurements = [
            SmartHomeChargeStateRaport({"device":storage, "date":start_date, "charge_value":storage.capacity-5})
        ]

        storage_raports = [
            # SmartHomeStorageChargingAndUsageRaport(device=storage, date_time_from=start_date, date_time_to=end_date)
        ]
        mock_measurements.return_value = measurements
        mock_storage.return_value = storage_measurements
        mock_raports.return_value = storage_raports

        energy_sources = OrderedDict([
                (sources.PHOTOVOLTAICS, PhotovoltaicsEnergyCalculator),
                (sources.GRID_SURPLUS, GridSurplusEnergyCalculator),
                (sources.ENERGY_STORAGE, EnergyStorageCalculator),
                (sources.PUBLIC_GRID, PublicGridEnergyCalculator),
                ])

        _, source_raport, surpluses = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

        first_raport = source_raport[0]
        photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
        self.assertEqual(photovoltaics_data["value"],10)
        self.assertEqual(photovoltaics_data["price"],0)

        grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
        self.assertEqual(grid_surplus_data["value"],0)
        self.assertEqual(grid_surplus_data["price"],0)

        energy_storage_data = first_raport.energy_sources[sources.ENERGY_STORAGE]
        self.assertEqual(energy_storage_data["value"],0)
        self.assertEqual(energy_storage_data["price"],0)

        first_surplus = surpluses[0]
        energy_storage_data = first_surplus[sources.ENERGY_STORAGE]
        expected_storaged_energy = 0.0144
        self.assertEqual(round(energy_storage_data, 5),expected_storaged_energy)

        grid_surplus_data = first_surplus[sources.GRID_SURPLUS]
        self.assertEqual(round(grid_surplus_data, 5),5-expected_storaged_energy)

    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_energy_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_raports')
    def test_calculate_grid_surplus_is_enough_to_charge_energy_storage(self, mock_raports, mock_storage, mock_measurements):
        """Devices didnt take any energy and zero energy generation by photovoltaics
            but is surplus in public grid to store in energy storage"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        generator = db["generators"][0]
        storage = EnergyStorage.objects.create(name='storage', building=building, capacity=6, battery_voltage=24)

        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=0),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=0)
        ]

        storage_measurements = [
            SmartHomeChargeStateRaport({"device":storage, "date":start_date, "charge_value":0})
        ]

        storage_raports = [
            # SmartHomeStorageChargingAndUsageRaport(device=storage, date_time_from=start_date, date_time_to=end_date)
        ]

        EnergySurplusRaport.objects.create(building = building, value=10, date_time = start_date, usage_type = EnergySurplusRaport.TRANSFER)

        mock_measurements.return_value = measurements
        mock_storage.return_value = storage_measurements
        mock_raports.return_value = storage_raports

        energy_sources = OrderedDict([
                (sources.PHOTOVOLTAICS, PhotovoltaicsEnergyCalculator),
                (sources.GRID_SURPLUS, GridSurplusEnergyCalculator),
                (sources.ENERGY_STORAGE, EnergyStorageCalculator),
                (sources.PUBLIC_GRID, PublicGridEnergyCalculator),
                ])

        _, source_raport, surpluses = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

        first_raport = source_raport[0]
        photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
        self.assertEqual(photovoltaics_data["value"],0)
        self.assertEqual(photovoltaics_data["price"],0)

        expected_storaged_energy = 0.0144


        grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
        self.assertEqual(round(grid_surplus_data["value"],5),expected_storaged_energy)
        self.assertEqual(grid_surplus_data["price"],0)

        energy_storage_data = first_raport.energy_sources[sources.ENERGY_STORAGE]
        self.assertEqual(energy_storage_data["value"],0)
        self.assertEqual(energy_storage_data["price"],0)

        first_surplus = surpluses[0]
        energy_storage_data = first_surplus[sources.ENERGY_STORAGE]
        self.assertEqual(round(energy_storage_data, 5),expected_storaged_energy)

        grid_surplus_data = first_surplus[sources.GRID_SURPLUS]
        self.assertEqual(round(grid_surplus_data, 5),0)

    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_energy_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_raports')
    def test_calculate_photovoltaics_is_enough_to_charge_energy_storage(self, mock_raports, mock_storage, mock_measurements):
        """Energy generated by photovoltaics + from energy exchange are enought to power every device"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        generator = db["generators"][0]
        storage = EnergyStorage.objects.create(name='storage', building=building, capacity=6, battery_voltage=24)

        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=10),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=5)
        ]

        exchange_price = 0.6
        ExchangeEnergyStorageRaport.objects.create(building=building,date_time_from=start_date, date_time_to=end_date,total_value=10, remained_value=5, purchase_price=exchange_price)

        storage_measurements = [
            SmartHomeChargeStateRaport({"device":storage, "date":start_date, "charge_value":storage.capacity})
        ]

        storage_raports = [
            # SmartHomeStorageChargingAndUsageRaport(device=storage, date_time_from=start_date, date_time_to=end_date)
        ]
        
        mock_measurements.return_value = measurements
        mock_storage.return_value = storage_measurements
        mock_raports.return_value = storage_raports

        energy_sources = OrderedDict([
                (sources.PHOTOVOLTAICS, PhotovoltaicsEnergyCalculator),
                (sources.ENERGY_EXCHANGE, EnergyExchangeCalculator),
                (sources.GRID_SURPLUS, GridSurplusEnergyCalculator),
                (sources.ENERGY_STORAGE, EnergyStorageCalculator),
                (sources.PUBLIC_GRID, PublicGridEnergyCalculator),
                ])

        _, source_raport, surpluses = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

        first_raport = source_raport[0]
        photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
        self.assertEqual(photovoltaics_data["value"],5)
        self.assertEqual(photovoltaics_data["price"],0)

        energy_exchange_data = first_raport.energy_sources[sources.ENERGY_EXCHANGE]
        self.assertEqual(energy_exchange_data["value"],5)
        self.assertEqual(energy_exchange_data["price"],Decimal(5*exchange_price))

        grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
        self.assertEqual(grid_surplus_data["value"],0)
        self.assertEqual(grid_surplus_data["price"],0)

        energy_storage_data = first_raport.energy_sources[sources.ENERGY_STORAGE]
        self.assertEqual(energy_storage_data["value"],0)
        self.assertEqual(energy_storage_data["price"],0)

        first_surplus = surpluses[0]
        energy_storage_data = first_surplus[sources.ENERGY_STORAGE]
        self.assertEqual(round(energy_storage_data, 5),0)

        grid_surplus_data = first_surplus[sources.GRID_SURPLUS]
        self.assertEqual(round(grid_surplus_data, 5),0)

    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_energy_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_measurements')
    @patch('smarthome.measurements_manager.EnergyMeasurementsManager._get_storage_raports')
    def test_calculate_exchange_energy_is_enough_to_charge_energy_storage(self, mock_raports, mock_storage, mock_measurements):
        """Energy generated by photovoltaics is enought to power every device,
            and we also have exchange energy that can be stored in the storage
        """

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        generator = db["generators"][0]
        storage = EnergyStorage.objects.create(name='storage', building=building, capacity=6, battery_voltage=24)

        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=5),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=5)
        ]

        exchange_price = 0.6
        ExchangeEnergyStorageRaport.objects.create(building=building,date_time_from=start_date, date_time_to=end_date,total_value=10, remained_value=0.01, purchase_price=exchange_price)

        storage_measurements = [
            SmartHomeChargeStateRaport({"device":storage, "date":start_date, "charge_value":0})
        ]

        storage_raports = [
            # SmartHomeStorageChargingAndUsageRaport(device=storage, date_time_from=start_date, date_time_to=end_date)
        ]
        mock_measurements.return_value = measurements
        mock_storage.return_value = storage_measurements
        mock_raports.return_value = storage_raports

        energy_sources = OrderedDict([
                (sources.PHOTOVOLTAICS, PhotovoltaicsEnergyCalculator),
                (sources.ENERGY_EXCHANGE, EnergyExchangeCalculator),
                (sources.GRID_SURPLUS, GridSurplusEnergyCalculator),
                (sources.ENERGY_STORAGE, EnergyStorageCalculator),
                (sources.PUBLIC_GRID, PublicGridEnergyCalculator),
                ])

        _, source_raport, surpluses = EnergyMeasurementsManager(building, energy_sources).download_home_energy(start_date, end_date)

        first_raport = source_raport[0]
        photovoltaics_data = first_raport.energy_sources[sources.PHOTOVOLTAICS]
        self.assertEqual(photovoltaics_data["value"],5)
        self.assertEqual(photovoltaics_data["price"],0)

        energy_exchange_data = first_raport.energy_sources[sources.ENERGY_EXCHANGE]
        self.assertEqual(energy_exchange_data["value"],0)
        self.assertEqual(energy_exchange_data["price"],0)

        grid_surplus_data = first_raport.energy_sources[sources.GRID_SURPLUS]
        self.assertEqual(grid_surplus_data["value"],0)
        self.assertEqual(grid_surplus_data["price"],0)

        energy_storage_data = first_raport.energy_sources[sources.ENERGY_STORAGE]
        self.assertEqual(energy_storage_data["value"],0)
        self.assertEqual(energy_storage_data["price"],0)

        first_surplus = surpluses[0]
        energy_storage_data = first_surplus[sources.ENERGY_STORAGE]
        self.assertEqual(round(energy_storage_data, 5),0.01)

        grid_surplus_data = first_surplus[sources.GRID_SURPLUS]
        self.assertEqual(round(grid_surplus_data, 5),0)
