from datetime import datetime
from decimal import Decimal, ROUND_HALF_UP
from django.test import TestCase
from django.urls import reverse_lazy
from mock import patch
from .energy_manager import BuildingEnergyManager
from rest_framework.test import APIClient
from users.models import User

from .models import Building, EnergyDailyMeasurement, EnergyGenerator, EnergyReceiver, EnergySurplusLossRaport, EnergySurplusRaport
from .energy_manager import PHOTOVOLTAICS, PUBLIC_GRID, GRID_SURPLUS


class EnergyTestCase(TestCase):
    client = APIClient()

    def setUpBuildingSinglePhotovoltaics(self):
        user = User.objects.create(email="defaultuser@email.com", password="defaultpassword")
        building = Building.objects.create(user=user, name="house")
        receiver = EnergyReceiver.objects.create(building=building, name="bulb", state=False, device_power=60, supply_voltage=8)
        generator = EnergyGenerator.objects.create(name='photovoltaics1', building=building, generation_power = 635.0)
        return {
            "building": building,
            "devices": [receiver],
            "generators": [generator]
        }


    def test_calculate_single_photovoltaics_is_enough(self):
        """Energy generated by single photovoltaics is enough to power every device"""

        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        generator = db["generators"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=5),
            EnergyDailyMeasurement(device=generator, datetime=end_date,energy_value=10)
        ]

        with patch.object(BuildingEnergyManager, '_download_energy_data_task_tmp', return_value=measurements):
            _, source_raport = BuildingEnergyManager(building).manage_building_energy(start_date, end_date)

            self.assertEqual(len(source_raport.energy_sources), 1)
            photovoltaics_data = source_raport.energy_sources[PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],5)
            self.assertEqual(photovoltaics_data["price"],0)

            surplus =  EnergySurplusRaport.objects.filter(building=building).latest('date_time')
            surplus_loss = EnergySurplusLossRaport.objects.filter(building=building).latest('date_time')
            
            self.assertEqual(surplus.usage_type, EnergySurplusRaport.TRANSFER)
            self.assertEqual(surplus.value, 0.8*5) #80 percent of unused energy
            self.assertEqual(surplus_loss.value, 0.2*5)


    def test_calculate_no_photovoltaics_public_grid_only(self):
        """There is no photovoltaics so its necessary to use only the public grid energy"""
        db = self.setUpBuildingSinglePhotovoltaics()
        building = db["building"]
        receiver = db["devices"][0]
        
        start_date = datetime(2022,3,29, 10,0,0)
        end_date = datetime(2022,3,29, 10,59,59)

        measurements = [
            EnergyDailyMeasurement(device=receiver, datetime=end_date,energy_value=5),
        ]

        with patch.object(BuildingEnergyManager, '_download_energy_data_task_tmp', return_value=measurements):
            _, source_raport = BuildingEnergyManager(building).manage_building_energy(start_date, end_date)

            print(source_raport.energy_sources)
            self.assertEqual(len(source_raport.energy_sources), 3)
            photovoltaics_data = source_raport.energy_sources[PHOTOVOLTAICS]
            self.assertEqual(photovoltaics_data["value"],0)
            self.assertEqual(photovoltaics_data["price"],0)
            public_grid_data = source_raport.energy_sources[PUBLIC_GRID]
            self.assertEqual(public_grid_data["value"],5)
            self.assertEqual(public_grid_data["price"],Decimal("3.4"))
